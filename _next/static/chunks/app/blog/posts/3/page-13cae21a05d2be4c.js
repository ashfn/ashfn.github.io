(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[477],{57761:(e,t,a)=>{Promise.resolve().then(a.bind(a,60644))},60644:(e,t,a)=>{"use strict";a.r(t),a.d(t,{default:()=>m});var n=a(95155);let s="hiding messages in playing cards";var o=a(48173),i=a.n(o),r=a(76559),l=a(12115),c=a(15266),d=a(53861),h=a(5565),u=a(3104);function m(){return(0,l.useEffect)(()=>{document.title="".concat(s," | Asher Falcon")},[]),(0,n.jsx)("div",{className:"h-screen bg-ashwhite",children:(0,n.jsxs)(r.PageTransition,{children:[(0,n.jsxs)("div",{style:{paddingTop:"50px"},className:"relative flex justify-center items-center h-[50px]",children:[(0,n.jsx)("div",{className:"absolute left-0 flex items-center h-full ml-6",children:(0,n.jsx)(c.default,{defaultPath:"/blog"})}),(0,n.jsx)("span",{className:"text-sm sm:text-base md:text-xl lg:text-2xl truncate max-w-[80%]",children:s})]}),(0,n.jsx)("div",{style:{paddingTop:"30px"},className:"flex justify-center items-center md:w-[70%] xl:w-[50%] w-[85%] mx-auto",children:(0,n.jsx)("div",{children:(0,n.jsx)("p",{children:"I was recently thinking about the huge number of ways you can shuffle a deck of 52 cards and wondered if it would be possible to store arbitrary data, which I explore in this blog post."})})}),(0,n.jsx)("div",{style:{paddingTop:"30px",paddingBottom:"30px"},className:"flex flex-col justify-center items-center md:w-[70%] xl:w-[50%] w-[85%] mx-auto",children:(0,n.jsxs)("p",{children:["This blog post will go into the detail of how I found a way to store text inside the order of a deck of cards. If you want to play around with the tool, go ",(0,n.jsx)(i(),{href:"https://deckcrypt.github.io/",target:"_blank",className:"text-blue-500",children:"here"}),". How many different ways can we shuffle a deck of 52 cards? We can think of it like picking one card from 52, then one from the remaining 51, and so on. We would get an expression that looks like ",(0,n.jsx)(d.Ay,{expression:"(52)\\cdot(52-1)\\cdot(52-2)\\cdot...\\cdot(52-51)"}),", which is the same as the factorial of 52, which is shown as ",(0,n.jsx)(d.Ay,{expression:"52!"}),". If we evaluate ",(0,n.jsx)(d.Ay,{expression:"52!"})," we get around ",(0,n.jsx)(d.Ay,{expression:"8 \\cdot 10^{67}"}),". This tells us that the number of bits that can be represented by a deck of cards is ",(0,n.jsx)(d.Ay,{expression:"\\left\\lfloor log_2(8 \\cdot 10^{67}) \\right\\rfloor"}),", or ",(0,n.jsx)(d.Ay,{expression:"225"})," bits. But how do we actually store arbitrary bits? We need a one-to one mapping between the order of the cards and the theoretically usable bits. Initial thinking made me believe it could be done by using the color of the cards, because a deck of 52 cards will have 26 black cards and 26 red cards, however that would, in a worst-case scenario, only give you ",(0,n.jsx)(d.Ay,{expression:"26"})," bits, only ",(0,n.jsx)(d.Ay,{expression:"11.\\dot5"}),"% of our theoretical limit. I later came across the concept of a ",(0,n.jsx)(i(),{href:"https://en.wikipedia.org/wiki/Lehmer_code",target:"_blank",className:"text-blue-500",children:"Lehmer code"}),", which allows you to numerically represent each unique permutation of set of elements. The easiest way to compute a Lehmer code is to make each element have its own number or id, and then for each element we count the number of elements to the right of it that are less than it. An animation of this process is below."]})}),(0,n.jsx)("div",{style:{paddingTop:"30px",paddingBottom:"30px"},className:"flex flex-col justify-center items-center md:w-[70%] xl:w-[50%] w-[85%] mx-auto",children:(0,n.jsx)(h.default,{className:"rounded-lg border-2 border-[#000000]",src:"/animation1.gif",alt:"output",width:600,height:400,about:"Animation of the process of computing a Lehmer code."})}),(0,n.jsx)("div",{style:{paddingTop:"30px",paddingBottom:"30px"},className:"flex flex-col justify-center items-center md:w-[70%] xl:w-[50%] w-[85%] mx-auto",children:(0,n.jsxs)("p",{children:["Another way to generate a lehmer code is to make a list of all the numbers you have, and for each number, find the index of the number of your list and then remove it. This is not as fast as the first method but its a bit easier to implement. Now that we can turn our deck of 52 cards into a Lehmer code, how can we actually use that to store data? We have our code as a list of cards ",(0,n.jsx)(d.Ay,{expression:"i=0,1,2 ... 51"})," where each card's code ",(0,n.jsx)(d.Ay,{expression:"N_i"})," can be in the range ",(0,n.jsx)(d.Ay,{expression:"[0, 51 -i]"}),". It is difficult to take that and just store arbitrary data using this array, so we can finally convert it a (very large) denary base10 number. We can do this because this Lehmer code is given to us as a ",(0,n.jsx)(i(),{href:"https://en.wikipedia.org/wiki/Factorial_number_system",target:"_blank",className:"text-blue-500",children:"factorial number"}),". The factorial number system represents numbers using how many factorial numbers you need to make it. For example, let's try to turn the denary number 17 into a factorial number. We use the factorial numbers ",(0,n.jsx)(d.Ay,{expression:"1, 1, 2, 6, 24, 120 ..."})," and so if we wanted to make 17 we would use two 6s, two 2s, and one 1, giving us a factoradic of ",(0,n.jsx)(d.Ay,{expression:"2:2:1:0_!"})," (Numbers in the factorial system are separated by colons and end with a !). We can convert from this back to decimal in a trivial way by just adding the factorial numbers for each factoradic digit. Some code for converting between decimal and factoradic is below."]})}),(0,n.jsx)(u.A,{language:"python",code:"\ndef convertToFactoradic(number: int) -> [int]:\n    result = []\n    divisor = 1\n    while(number > 0):\n        result.insert(0, number % divisor)\n        number //= divisor\n        divisor+=1\n    return result\n\ndef convertToDenary(number: [int]) -> int:\n    global factorials\n    result = 0\n    numlen = len(number)\n    for i in range(numlen):\n        result += number[i]*factorials[numlen-i-1]\n    return result\n"}),(0,n.jsx)("div",{style:{paddingTop:"30px",paddingBottom:"30px"},className:"flex flex-col justify-center items-center md:w-[70%] xl:w-[50%] w-[85%] mx-auto",children:(0,n.jsxs)("p",{children:["Now we can use this to store huge numbers inside our deck of cards. Shuffle a deck and run its permutation through the Lehmer code process, and then turn its factoradic number into a decimal number, and it will be ",(0,n.jsx)("b",{children:"huge"}),". This is because its storing our 225 bits of data in a number. We have found a way to use ",(0,n.jsx)(d.Ay,{expression:"100"}),"% of bits we calculated previously. But how can we make this usable? We have 225 bits to play around with and so if we wanted to store alphabetical characters, we could use ",(0,n.jsx)(d.Ay,{expression:"\\lceil log_2(26) \\rceil = 5"})," bits per character, which would leave us with some extra 6 characters. Most important is a space character, and after that I think a full stop is useful. If people want to put domains in there I thought a / slash might be useful. Finally a quotation mark, comma and dash are added to get our 5 bit, 32 symbol character set. With 5 bits per character, our 225 bits can store ",(0,n.jsx)(d.Ay,{expression:"\\frac{225}{5} = 45"})," characters."]})}),(0,n.jsx)(u.A,{language:"python",code:'alphabet = " .,-\\"/abcdefghijklmnopqrstuvwxyz"'}),(0,n.jsx)("div",{style:{paddingTop:"30px",paddingBottom:"30px"},className:"flex flex-col justify-center items-center md:w-[70%] xl:w-[50%] w-[85%] mx-auto",children:(0,n.jsx)("p",{children:"In Python converting text to and from a 225 bit number is quite simple and just requires some bitwise operations. Additionally, the function to convert a number to a permutation just requires converting it to a factoradic and then using each digit to index into a list of available elements, removing each element after it is used."})}),(0,n.jsx)(u.A,{language:"python",code:'\ndef convertToPermutation(number: int, permutationElements: int) -> [int]:\n    global factorials\n    if(number >= factorials[permutationElements]):\n        raise ValueError("Given number is outside of permutation range")\n    factoradic = convertToFactoradic(number)\n    while len(factoradic) < permutationElements:\n        factoradic.insert(0,0)\n    available = list(range(permutationElements))\n    permutation = []\n    for i in factoradic:\n        permutation.append(available[i])\n        available.pop(i)\n    return permutation\n\ndef textToPackOfCards(text: str) -> [int]:\n    global alphabet\n    if(len(text) > 45):\n        raise ValueError("Text must be <=45 characters to be represented in one deck of cards")\n    for i in text.lower():\n        if not i in alphabet:\n            raise ValueError("Text must only be characters A-Z or \'., -\\"/\' in order to use 5bit")\n    data = 0\n    for i in text.lower():\n        data<<=5\n        data|=alphabet.index(i)\n    data <<= (5*(45-len(text)))\n    return convertToPermutation(data, 52)\n'}),(0,n.jsx)("div",{style:{paddingTop:"30px",paddingBottom:"30px"},className:"flex flex-col justify-center items-center md:w-[70%] xl:w-[50%] w-[85%] mx-auto",children:(0,n.jsx)("p",{children:"The overall process of converting text to a deck of cards is shown below, and the main reason this works to both encode and decode is that each step shown is reversible."})}),(0,n.jsx)("div",{style:{paddingTop:"30px",paddingBottom:"30px"},className:"flex flex-col justify-center items-center md:w-[70%] xl:w-[50%] w-[85%] mx-auto",children:(0,n.jsx)(h.default,{src:"/img10.png",alt:"output",width:600,height:400,about:"Animation of the process of converting text to a deck of cards."})}),(0,n.jsx)("div",{style:{paddingTop:"30px",paddingBottom:"30px"},className:"flex flex-col justify-center items-center md:w-[70%] xl:w-[50%] w-[85%] mx-auto",children:(0,n.jsxs)("p",{children:["I tested it out, and it worked pretty well. One interesting side effect of using Lehmer codes is that if you change a card, all the characters after that card will be affected, and characters before will be fine. I hacked together a website where I ported the functions to c++ and used WebAssembly/Emscripten to make it run in the browser ",(0,n.jsx)("i",{children:"Blazingly Fast \uD83D\uDD25"}),", I also added a simple XOR cipher with a second string of text if you want to 'encrypt' your message before it hits the deck, but I think it's probably not neccesary as no one would suspect that you've hidden a 46 character message in your deck of cards! Check it out ",(0,n.jsx)(i(),{href:"https://deckcrypt.github.io/",target:"_blank",className:"text-blue-500",children:"here"})," and I hope you enjoyed this read. This whole process from thinking of the idea to implementing it was a lot of fun and I'm glad I got to share it with you.If you have any questions or comments, please feel free to reach out to me ",(0,n.jsx)(i(),{href:"/contact",className:"text-blue-500",children:"here"}),"."]})})]})})}}},e=>{var t=t=>e(e.s=t);e.O(0,[562,206,913,606,173,126,565,203,441,517,358],()=>t(57761)),_N_E=e.O()}]);